# ARCHITECTURE

## Обзор

Проект построен по **feature-based (domain-first)** архитектуре: код группируется по доменам/фичам (например, `matches`). Это снижает связанность, упрощает развитие отдельных фич и делает масштабирование предсказуемым.

Ключевые принципы:
- **Домен = папка фичи** (`features/matches`)
- **UI — декларативный и “тупой”**
- **Pinia — единый источник истины**
- **WebSocket подключается один раз** на всё приложение

---

## Оптимизация под частые обновления коэффициентов

### 1) Точечная мутация в Pinia

Для live-обновлений коэффициентов используется точечная мутация объекта без пересоздания массива.

```ts
const match = matches.value.find(m => m.id === id)
if (match) {
  match.coeff = coeff
}
```

Это позволяет Vue выполнять минимальный DOM-patch и обновлять только изменившиеся элементы.
Vue прекрасно понимает, какие части приложения будут перерисованы(используя теги):

Пару слов из спеки:
- **Patch flags** позволяют Vue во время diff точно знать,
  *какие именно части узла могут изменяться* (текст, классы, атрибуты),
  и пропускать проверки для статичных частей.
- **Static hoisting** выносит полностью статичные узлы за пределы render-функции,
  благодаря чему они не участвуют в последующих рендерах вообще.


В результате при обновлении `match.coeff` Vue:
- не пересобирает виртуальное DOM-дерево целиком
- не сравнивает статичные узлы
- выполняет минимальный patch только для тех тегов,
  которые действительно зависят от изменённых данных

### 2) Расчёты trend и delta в Pinia

Вычисления направления изменения коэффициента (`trend`) и величины изменения (`delta`) выполняются в Pinia в момент обновления данных.

```ts
const old = match.coeff
match.coeff = coeff

if (coeff === old) {
  match.trend = Trend.Same
  match.delta = 0
} else {
  match.trend = coeff > old ? Trend.Up : Trend.Down
  match.delta = coeff - old
}
```

UI-компоненты получают уже готовые данные и не содержат watcher-ов.

---

## Схема Pinia-хранилища

```
matchesStore
 ├─ matches: MatchesModel[]
 ├─ loading: boolean
 └─ error: string | null
```

### MatchesModel

```
MatchesModel
 ├─ id: number
 ├─ teamA: string
 ├─ teamB: string
 ├─ score: string
 ├─ coeff: number
 ├─ trend: Trend
 └─ delta: number
```

---

## Логика WebSocket

WebSocket-подключение инициализируется через доменный плагин и существует в единственном экземпляре.

Поток данных:
```
WebSocket message
 → validate payload
 → matchesStore.updateCoeff
 → reactive update
 → DOM patch
```

---

## UI-компоненты и ответственность

### Главная страница
- **MatchesTable** — структура таблицы
- **MatchesTableRow** — одна строка матча
- **OddsCell** — отображение коэффициента и delta/trend

### Детальная страница
- **MatchController** — получение матча по id(Здесь не предусматривается отдельный запрос на бэк по id, но в реальном кейсе должен быть)
- **MatchDetailsCard** — команды и счёт
- **MatchOddsCard** — коэффициент, delta и trend

---

## Масштабирование до 10k+ событий

Данный вопрос преимущественно решается на бэкенде/сервере, т.к фронт по сути ждёт пока бэк сходит в базу и подготовит данные.

Для масштабирования до 10 000+ событий предполагается:
- перенос основных вычислений на backend
- минимизация payload WebSocket
- пагинация, ограничение отображаемой области(чтобы не было утечек памяти)
- распределение нагрузки между контейнерам(если такие имеются)
- если SSR, то здесь нужно увеличивать мощности сервера, а лучше избавляться от него в данном случае. И переходить на SPA
- избегать слушателей/вотчеров на "часто обновляемых" компонентах
- наличие key, избегать перезаписи массива
- правильная перерисовка лэйаутов и компонентов(чтобы кэшировалось), в nuxt решает по умолчанию, на нативном vue, я бы использовал подход от Сергей Миртов(на ютуб можете посмотреть)
---

## Итог

Архитектура обеспечивает:
- точечные обновления UI
- предсказуемое поведение при live-данных
- простоту масштабирования
- чёткое разделение ответственности между слоями
